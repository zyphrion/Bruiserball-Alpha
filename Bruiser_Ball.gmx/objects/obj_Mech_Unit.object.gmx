<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>spr_Mech</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>0</depth>
  <persistent>0</persistent>
  <parentName>&lt;undefined&gt;</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Initilization
init = 0;
x = 0;
y = 0;
x_old = x;
y_old = y;

direction = 0; //the direction the mech is moving
facing = 0; //the direction the mech is oriented
net_movement_direction = facing; //the direction the net thrust is directed
image_angle = facing;

//void reactor
energy = 100;

//chassis
//Light Chassis = 10,000, Medium Chassis = 12,500, Heavy Chassis = 15,000
chassis_mass = 15000+1000+2000;//we are acting as those there is a loadout as well

thruster_back_main_force = 0;
thruster_back_main_weight = 2000;
thruster_hand_left_force = 0;
thruster_hand_left_weight = 500;
thruster_hand_right_force = 0;
thruster_hand_right_weight = 500;
thruster_leg_left_force = 0;
thruster_leg_left_weight = 1000;
thruster_leg_right_force = 0;
thruster_leg_right_weight = 1000;

thruster_mass_total = thruster_back_main_weight +
thruster_hand_left_weight + thruster_hand_right_weight +
thruster_leg_left_weight + thruster_leg_right_weight;

thruster_force_total = thruster_back_main_force +
thruster_hand_left_force + thruster_hand_right_force +
thruster_leg_left_force + thruster_leg_right_force;

//physics stuff
//mass is in kg and thrust force is in newtons
mass = thruster_mass_total + chassis_mass;
thrust = 200000;
acceleration = (thrust/mass*16);

//drag/wind resistance
//drag = 1/2 * fluid dsensity kg/m3 * velocity m/s * drag coefficient * reference area m/s^2
fluid_density = 1.225;
velocity = speed/16;
//default_drag_coefficient = 1.1;
default_drag_coefficient = .20//;.42;
drag_coefficient = default_drag_coefficient;
default_reference_area = 114;
reference_area = default_reference_area;
drag = 1/2 * fluid_density * velocity * drag_coefficient * reference_area;

thrust_to_weight = thrust / (mass * 9.807);

input_brakes_timer = 0;
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Debugging Stuff
//this will need to be a script
momentum_overlay  = 1;
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Movement &amp; Collision Prechecking
x_next = x;
y_next = y;
hspeed_next = 0;
vspeed_next = 0;
x_collision_path[] = 0;//this will be sent to a physics checker object
y_collision_path[] = 0;
collision_instances[] = 0;
collision_first_instance = 0;
collision = false;
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="2">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Viewport Code
//viewport must rotate in such a way to keep the player looking up.
image_angle = facing;
view_angle[0] = -image_angle+90; //&lt;-- This does it!!!
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Reconcile Movement - This will allow for pre-checking, and multi-object collisions
if(collision = true)
{
    move_contact_all(direction,distance_to_point(x_next,y_next));
    //move_bounce_all(true);
    x = x_collision_path[collision_first_instance];
    y = y_collision_path[collision_first_instance];
    hspeed_next = 0;
    vspeed_next = 0;
    speed = 0;
    collision_first_instance = 0;
    collision_instances[]= 0;
    x_collision_path[] = 0;
    y_collision_path[] = 0;
    collision = false;
}
else{
hspeed = hspeed_next;
vspeed = vspeed_next;
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="1">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Initialization
if(init = 0)
{
    x = obj_Arena_Parent.center_x;
    y = obj_Arena_Parent.center_y;
    init = 1;
}
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Input Reader
//movement state
//thrust
if(keyboard_check(ord('W'))){
input_thrust = 1;}
else if(keyboard_check(ord('S'))){
input_thrust = 2;}
else
{input_thrust = 0;}
//turn &amp;&amp; strafe
//if q or e are pressed while the mech is still, then you strafe slowly
//double tapping will cause you to boost strafe
//if you are moving, you will move at a 45 degree while still facing your target
//double tapping will cause you to to use a boost manuever

//if a or d are pressed while mech is still, then you rotate slowly
//double tapping will cause a boost rotation
//if you are moving, you will turn in an arc
//double tapping will cause a boose rotation
if(keyboard_check(ord('A'))){
input_turn = 1;}
else if(keyboard_check(ord('D'))){
input_turn = 2;}
else if(keyboard_check(ord('Q'))){
input_turn = 3;}
else if(keyboard_check(ord('E'))){
input_turn = 4;}
else
{input_turn = 0;}
//brakes
if(keyboard_check(vk_shift))
{
    input_brakes = 1;
    if(keyboard_check_pressed(vk_shift))
    {
        if(input_brakes_timer == 0)
        {
            input_brakes_timer = 1;}}}
else
{input_brakes = 0;}
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Timer Code
//input timers
// 0 = ready, 1 = active, 2 = expired
//brakes timer
if(input_brakes == 1)
{
    input_brakes_timer++;
}
if(input_brakes == 2)
{
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Movement Code - Must convert to state machine &amp; controller architecture
/*
Single Press//Double Press
W - Thrust Foward//Boost Forward
S - Thrust Backward//Boost Backward
A - Rotate Counter-Clockwise//Boost Counter-Clockwise
D - Rotate Clockwise//Boost Clockwise
Shift - Air Brakes//Booster Brakes
*/


/*
direction will keep track of the direction a player is currently moving
facing keeps track of the direction they are facing
aim_angle keeps track of head look for fog of war and aiming abilities

*/

aim_angle = point_direction(x,y,mouse_x,mouse_y);

switch(input_turn)
{
    case 0:
        net_movement_direction = facing;
    break;
    case 1://rotate counter clockwise
    facing+=3;
    break;
    case 2://rotate clockwise
    facing-=3;
    break;
    case 3://strafe left
    if(input_thrust == 0)//if main thrusters aren't engaged
    {
        net_movement_direction = facing+90;
        hspeed_next += cos(degtorad(net_movement_direction))*acceleration/room_speed;
        vspeed_next += -sin(degtorad(net_movement_direction))*acceleration/room_speed;}
    if(input_thrust == 1)
    {
        net_movement_direction = facing+45;}
    if(input_thrust == 2){
        net_movement_direction = facing+45;}
    break;
    case 4://strafe right
    if(input_thrust == 0)//if main thrusters aren't engaged
    {
        net_movement_direction = facing-90;
        hspeed_next += cos(degtorad(net_movement_direction))*acceleration/room_speed;
        vspeed_next += -sin(degtorad(net_movement_direction))*acceleration/room_speed;}
    if(input_thrust == 1)
    {
        net_movement_direction = facing-45;}
    if(input_thrust == 2){
        net_movement_direction = facing-45;}
    break;
    default:
    break;
}
switch(input_thrust)
{
    case 0:
    break;
    case 1://forward
        hspeed_next += cos(degtorad(net_movement_direction))*acceleration/room_speed;
        vspeed_next += -sin(degtorad(net_movement_direction))*acceleration/room_speed;
    break;
    case 2://backwards
        hspeed_next -= cos(degtorad(net_movement_direction))*acceleration/room_speed;
        vspeed_next -= -sin(degtorad(net_movement_direction))*acceleration/room_speed;
    break;
    default:
    break;
}
switch(input_brakes)
{
    case 0:
    reference_area = default_reference_area;
    drag_coefficient = default_drag_coefficient;
    break;
    case 1://air brakes - this will change to effect drag
    if(speed &gt;= .5)
    {
        //speed -= cos(degtorad(direction))*.5;
        //vspeed_next -= -sin(degtorad(direction))*.5;
        reference_area = default_reference_area + 3;
        drag_coefficient = 1;
        }
    else if(speed &gt; 0 &amp;&amp; speed &lt; .5)
    {
        hspeed_next = 0;
        vpseed_next = 0;}
    break;
    default:
    break;
}

//this code is to keep player from running off map during testing
/*if(x &gt; room_width - 2000 || x &lt; 2000)
{x = room_width/2;}
if(y &gt; room_height - 2000 || y &lt; 2000)
{y = room_height/2;}*/
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Physics - This will go into a parent object at some point
fluid_density = 1.225;
velocity = speed/16;
//reference_area = 2.5;
thrust_to_weight = thrust / mass * 9.807;
//drag = 1/2 * fluid density kg/m3 * velocity m/s * drag coeficient * reference area m/s^2
drag = 1/2 * fluid_density * velocity * drag_coefficient * reference_area;
hspeed_next -=cos(degtorad(direction))*drag/room_speed;
vspeed_next -= -sin(degtorad(direction))*drag/room_speed;
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Collision Code
x_next = x+hspeed_next;
y_next = y+vspeed_next;
// = distance_to_point(x+hspeed_next*cos(facing),y+vspeed_next*-sin(facing));
//if you are going to collide with a wall, you stop at the wall, future change will be to you sliding
//abs(hspeed_next*vspeed_next)
for(i = 0; i &lt;= distance_to_point(x_next,y_next); i++){
    x_collision_path[i] = x+i*cos(degtorad(direction));
    y_collision_path[i] = y-i*sin(degtorad(direction));
    collision_instances[i] = position_meeting(x_next,y_next,obj_Wall_Parent);
    if(collision_instances[i] != 0 &amp;&amp; collision_first_instance == 0)
    {
        collision_first_instance = i;
        collision = true;
    }
    else
    {
    }
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="64">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///speed overlay
draw_text(0,0,"Current Speed: " + string(speed/16) + " m/s");
speed_mph = speed/16*2.236936;
draw_text(0,10,"distance: " + string(distance_to_point(x+hspeed_next*cos(facing),y+vspeed_next*-sin(facing))) + " pixels");
draw_text(0,+20,"Drag: " + string(drag/16) + " m/s");
draw_text(0,+30,"Acceleration: " + string(acceleration/16) + " m/s^2");
draw_text(0,+40,"x: " + string(x) + " hspeed_next: " + string(hspeed_next));
draw_text(0,+50,"y: " + string(y) + " vspeed_next: " + string(vspeed_next));
draw_text(0,+60,"x_collision_path: " + string(x_collision_path[]));
draw_text(0,+70,"y_collision_path: " + string(y_collision_path[]));
draw_text(0,+80,"collision_first_instance: " + string(collision_first_instance));
draw_text(0,+90,"collision_instances[]: " + string(collision_instances[]));
draw_text(0,+100,"Facing: " + string(facing));

</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Grid Overlay - this needs to fixed to be rotatable
r = 50*16;//in meters
spacing = 10;//spacing of the grid
draw_circle(x,y,r,1);
for(i = 0; i &lt;= r;i++)
{
    angle_delta = 15*i;
    if(i mod (16*spacing) == 0)
    {
        //draw_line(x-r*-cos(degtorad(facing+45)),y+r*-sin(degtorad(facing+45)),x+r*-cos(degtorad(facing+135)),y+r*-sin(degtorad(facing+135)));
        //draw_line(x-r*cos(degtorad(facing+45)),y-i,x+r*cos(degtorad(-facing+45)),y-i);
        //horiontal lines
        //draw_line(x-r*16,y+i,x+r*16,y+i);
        //draw_line(x-r*16,y-i,x+r*16,y-i);
        //vertical lines
        //draw_line(x+i,y-r*16,x+i,y+r*16);
        //draw_line(x-i,y-r*16,x-i,y+r*16);
        //draw_line(x+i,y+r*-sin(degtorad(facing+45)),x+i,y+r*-sin(degtorad(-facing+45)));
        //draw_line(x-i,y+r*-sin(degtorad(facing+45)),x-i,y+r*-sin(degtorad(-facing+45)));
    }
}
    
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///momentum overlay - this need to be a script
if(momentum_overlay == 1)
{
    draw_set_color(c_red);
    draw_arrow(x,y,x+hspeed,y+vspeed*3,20);
    draw_set_color(c_white);
    //draw_arrow(x,y,x+hspeed_next,y+vspeed_next,20);
}
draw_sprite_ext(spr_Mech,0,x,y,1,1,facing,-1,1);
</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints/>
</object>
